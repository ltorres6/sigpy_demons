import sigpy as sp
import finiteDifferences as fd


def compose(field1, field2, diffeomorphic=False, compositionType="A", device=-1):
    if diffeomorphic is False:
        # print("NotDiffeomorphic")
        """
        This function warps field2 to space of field1 and adds for proper composition in euclidian space.
        Interpolate using sigpy. param = 1 is linear.
        """
        xp = sp.Device(device).xp
        shape = field1.shape
        if shape[0] == 2:
            nd, nx, ny = field1.shape
            coord = xp.mgrid[0:nx, 0:ny].astype("float64")
        elif shape[0] == 3:
            nd, nx, ny, nz = field1.shape
            coord = xp.mgrid[0:nx, 0:ny, 0:nz].astype("float64")

        fieldOut = sp.interpolate(
            field2,
            xp.moveaxis(coord, 0, -1) + xp.moveaxis(field1, 0, -1),
            kernel="spline",
            width=2,
            param=1,
        )
        fieldOut += field1
        return fieldOut
    elif diffeomorphic is True:
        # print("Diffeomorphic")
        """
        Uses BCH approximation for composition of diffeomorphisims.
        A = V+U
        B = V+U + 0.5*(Jac(V)*U - Jac(U)*V)
        C = Not worth it.
        """
        if compositionType is "A":
            fieldOut = field1 + field2
        elif compositionType is "B":
            fieldOut = field1 + field2 + LieBracket(field1, field2, device=device)
        return fieldOut


def expfield(fieldIn, device=-1):
    # Scaling and Squaring Algorithm iLogDemons Paper
    # Find n, scaling parameter
    xp = sp.Device(device).xp
    # n big enough so max(v * 2^-n) < 0.5 pixel)
    n = 2 * xp.max(xp.sqrt(xp.sum(fieldIn ** 2, axis=0)))  # == 2^n
    if ~xp.isfinite(n) or n <= 0.0:
        n = 0
    else:
        n = int(xp.ceil(xp.log2(n)))

    # 1) Scaling Step (Scale towards 0 for efficient computation) # Compute exp(V/2^N)?
    scale = 2 ** -n
    fieldOut = fieldIn * scale
    # 2) square it n times to get exp(V)
    for _ in range(n):
        fieldOut = compose(fieldOut, fieldOut, device=device)

    return fieldOut


def LieBracket(fieldIn1, fieldIn2, device=-1):
    """
    Computes the Jacobiâ€“Lie bracket of vector fields. (commutator of vector fields)
    "Conceptually, [fieldIn1,fieldIn2]  is the derivative of fieldIn2 along the flow generated by fieldIn1" - Wikipedia
    Jac(fieldIn2)*fieldIn1-Jac(fieldIn1)*fieldIn2
    """
    xp = sp.Device(device).xp
    nDim = fieldIn1.shape[0]
    if nDim == 2:
        J1x, J1y = jacobian(fieldIn1, device=device)
        J2x, J2y = jacobian(fieldIn2, device=device)
    elif nDim == 3:
        J1x, J1y, J1z = jacobian(fieldIn1, device=device)
        J2x, J2y, J2z = jacobian(fieldIn2, device=device)

    a = xp.zeros(fieldIn1.shape)
    b = xp.zeros(fieldIn1.shape)
    if nDim == 2:
        for ii in range(nDim):
            a[ii] = J2x[ii] * fieldIn1[0] + J2y[ii] * fieldIn1[1]
            b[ii] = J1x[ii] * fieldIn2[0] + J1y[ii] * fieldIn2[1]
    if nDim == 3:
        for ii in range(nDim):
            a[ii] = J2x[ii] * fieldIn1[0] + J2y[ii] * fieldIn1[1] + J2z[ii] * fieldIn1[2]
            b[ii] = J1x[ii] * fieldIn2[0] + J1y[ii] * fieldIn2[1] + J1z[ii] * fieldIn2[2]

    # for ii in range(fieldIn1.shape[0]):
    #     for jj in range(fieldIn1.shape[0]):
    #         a[ii] += J2[jj, ii] * fieldIn1[jj]
    #         b[ii] += J1[jj, ii] * fieldIn2[jj]
    return 0.5 * (a - b)


def jacobian(fieldIn, device=-1):
    # xp = sp.Device(device).xp
    D = fd.CentralDifference(fieldIn.shape[1:])
    if len(fieldIn.shape[1:]) == 2:
        # common to add identity
        Jx = D * fieldIn[0]
        Jy = D * fieldIn[1]

        # # common to add identity
        # Jx[0] = Jx[0]
        # Jy[1] = Jy[1]

        # J = xp.array([Jx, Jy])
        return Jx, Jy
    elif len(fieldIn.shape[1:]) == 3:
        Jx = D * fieldIn[0]
        Jy = D * fieldIn[1]
        Jz = D * fieldIn[2]

        # # common to add identity
        # Jx[0] = Jx[0]
        # Jy[1] = Jy[1]
        # Jz[2] = Jz[2]

        # J = xp.squeeze(xp.array([Jx[0], Jy[1], Jz[2], Jx[0], Jy[1], Jz[2], Jx[0], Jy[1], Jz[2]]))
        # J = xp.array([Jx, Jy, Jz])
        return Jx, Jy, Jz


def jacobianDet(fieldIn):
    D = fd.CentralDifference(fieldIn.shape[1:])
    if len(fieldIn.shape[1:]) == 2:
        # common to add identity
        Dx = D * fieldIn[0]
        Dy = D * fieldIn[1]

        # common to add identity
        Dx[0] = Dx[0] + 1
        Dy[1] = Dy[1] + 1

        J = Dx[0] * Dy[1] - Dy[0] * Dx[1]

    elif len(fieldIn.shape[1:]) == 3:
        # common to add identity
        Dx = D * fieldIn[0]
        Dy = D * fieldIn[1]
        Dz = D * fieldIn[2]

        # common to add identity
        Dx[0] = Dx[0] + 1
        Dy[1] = Dy[1] + 1
        Dz[2] = Dz[2] + 1

        J = (
            Dx[0] * Dy[1] * Dz[2]
            + Dy[0] * Dz[1] * Dx[2]
            + Dz[0] * Dx[1] * Dy[2]
            - Dz[0] * Dy[1] * Dx[2]
            - Dy[0] * Dx[1] * Dz[2]
            - Dx[0] * Dz[1] * Dy[2]
        )
    return J
